# Binarized
#  Filter is now powers of two. Errors stay near 3%. Visibly less loud tested via audacity.
#  This is without decreasing the step size with time. 
#  It's currently taking about 20s to reliably cancel a 100Hz tone sampled at 1kHz. 
#     Try 2 seconds. Too little.
#         5          Much better.
#  Try a 10kHz tone + a 1kHz tone with amplitudes 1 each (max 2) sampled at 40kHz 
#     for 0.1 seconds - not enough. Can handle it though, sometimes.
#         0.2 - gets down to 20% error reliably.
#         5 works - 2,4% error. Tried.. 2 times. Good enough. Remember stopping updates after 3/4 time - so really closer to 3.5 seconds.
#  Try 
# Attempt 1
##    0-255 8-bit input, integer. Two-tone 1kHz sampling, 300, 100Hz tones, with each amplitude 128. Level-shift to 127 -> -128.
## 	  0-255 8-bit input, integer. Error signals. Level shift then take absolute value.
## 	  Change filtering to floor intermediate values, keeping things as integers. --> these changes, 0-DC, 255 AMP, rounding intermediates to integers, leads to 15% best-case error after 20 seconds. after 5 seconds we see almost no improvement.
## 	  Conclusion: try allowing up to 2^-2. So multiply by 4, round, then divide by 4. Then at the end, add and truncate.
# Attempt 2
## 	  The same as above, but with 2^-3 precision and 40 seconds. Now down to 5% error again. Acceptable for now.
##    So it seems 1/8 precision, truncation after adding, roughly 1 minute update times, and abs(0-DC error) is the right combination.
# Attempt 3
##	  Add accumulator values without truncating further, then level shift by + 128 and truncate to 0-255, storing 'truncated' flag. output this to DAC and keep scaling same meaning 0-255 mean the same thing.
## 	  In the s/w test it really means truncate to -128, +127 (for input peaking at +/-128). 
## 	  This works just as before - no real difference noted. Still at 5% error.	
# Attempt 4
# 	  LFSR random number generator.
# 		XNOR of Q60, 61, 63, and 64 for a 64 bit LFSR with bits 1:64 is described as maximal online. XNOR so 1111 is stuck state. We likely reset on power-on.
# 		This works just as well as uniform random number generator when seeded 1-5000 iterations into the LFSR. the base 0000 seed fails terribly because it takes a while
# 		to get a mix of ones and zeros in there. Therefore need user to seed the LFSR by pressing - even half a second would likely be a few thousand iterations.

# Attempt 5
# 	Try for minimum filter length. Does 16 work ok? --> yes, 20 works ok.. but let's keep it at 32 if we can. size/time don't seem to be major issues. 

#  Should parameterize everything in design that I can - it seems to scale that way at the surface. 
#   if necessary, test scale/precision required for error & filtering.  --> had to do. decided on 1/8 precision. scaling seems to increase time required.
#   if necessary, test solutions if high frequency of accumulator (filtering) overflow --> capping doesn't make much of a difference.
#   ignore output scale for now. will adjust manually -> agreed.
#   have only tested propagation delay (linear phase filter) with this method. possibly worth testing other filters. 
#    random filter, for example.. but then, if we know the filter, we can find it.. so for now, try one random filter, confirm we can match it, then proceed. --> out of time. not going to do this.
